// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/Security.proto

#ifndef PROTOBUF_INCLUDED_proto_2fSecurity_2eproto
#define PROTOBUF_INCLUDED_proto_2fSecurity_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_proto_2fSecurity_2eproto

namespace protobuf_proto_2fSecurity_2eproto {
// Internal implementation detail -- do not use these members.
    struct TableStruct {
        static const ::google::protobuf::internal::ParseTableField entries[];
        static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
        static const ::google::protobuf::internal::ParseTable schema[4];
        static const ::google::protobuf::internal::FieldMetadata field_metadata[];
        static const ::google::protobuf::internal::SerializationTable serialization_table[];
        static const ::google::protobuf::uint32 offsets[];
    };

    void AddDescriptors();
}  // namespace protobuf_proto_2fSecurity_2eproto
namespace proto {
    class ClientHello;

    class ClientHelloDefaultTypeInternal;

    extern ClientHelloDefaultTypeInternal _ClientHello_default_instance_;

    class ClientSecurity;

    class ClientSecurityDefaultTypeInternal;

    extern ClientSecurityDefaultTypeInternal _ClientSecurity_default_instance_;

    class ClientSecurityResponse;

    class ClientSecurityResponseDefaultTypeInternal;

    extern ClientSecurityResponseDefaultTypeInternal _ClientSecurityResponse_default_instance_;

    class ServerHello;

    class ServerHelloDefaultTypeInternal;

    extern ServerHelloDefaultTypeInternal _ServerHello_default_instance_;
}  // namespace proto
namespace google {
    namespace protobuf {
        template <>
        ::proto::ClientHello *Arena::CreateMaybeMessage <::proto::ClientHello>(Arena *);

        template <>
        ::proto::ClientSecurity *Arena::CreateMaybeMessage <::proto::ClientSecurity>(Arena *);

        template <>
        ::proto::ClientSecurityResponse *Arena::CreateMaybeMessage <::proto::ClientSecurityResponse>(Arena *);

        template <>
        ::proto::ServerHello *Arena::CreateMaybeMessage <::proto::ServerHello>(Arena *);
    }  // namespace protobuf
}  // namespace google
namespace proto {

// ===================================================================

    class ClientHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ClientHello) */ {
    public:
        ClientHello();

        virtual ~ClientHello();

        ClientHello(const ClientHello &from);

        inline ClientHello &operator=(const ClientHello &from) {
            CopyFrom(from);
            return *this;
        }

#if LANG_CXX11

        ClientHello(ClientHello &&from) noexcept
                : ClientHello() {
            *this = ::std::move(from);
        }

        inline ClientHello &operator=(ClientHello &&from) noexcept {
            if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                if (this != &from) InternalSwap(&from);
            } else {
                CopyFrom(from);
            }
            return *this;
        }

#endif

        static const ::google::protobuf::Descriptor *descriptor();

        static const ClientHello &default_instance();

        static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
        static inline const ClientHello *internal_default_instance() {
            return reinterpret_cast<const ClientHello *>(
                    &_ClientHello_default_instance_);
        }

        static constexpr int kIndexInFileMessages =
                0;

        void Swap(ClientHello *other);

        friend void swap(ClientHello &a, ClientHello &b) {
            a.Swap(&b);
        }

        // implements Message ----------------------------------------------

        inline ClientHello *New() const final {
            return CreateMaybeMessage <ClientHello>(NULL);
        }

        ClientHello *New(::google::protobuf::Arena *arena) const final {
            return CreateMaybeMessage <ClientHello>(arena);
        }

        void CopyFrom(const ::google::protobuf::Message &from) final;

        void MergeFrom(const ::google::protobuf::Message &from) final;

        void CopyFrom(const ClientHello &from);

        void MergeFrom(const ClientHello &from);

        void Clear() final;

        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input) final;

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const final;

        ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
                bool deterministic, ::google::protobuf::uint8 *target) const final;

        int GetCachedSize() const final { return _cached_size_.Get(); }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const final;

        void InternalSwap(ClientHello *other);

    private:
        inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
            return NULL;
        }

        inline void *MaybeArenaPtr() const {
            return NULL;
        }

    public:

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // string version = 1;
        void clear_version();

        static const int kVersionFieldNumber = 1;

        const ::std::string &version() const;

        void set_version(const ::std::string &value);

#if LANG_CXX11

        void set_version(::std::string &&value);

#endif

        void set_version(const char *value);

        void set_version(const char *value, size_t size);

        ::std::string *mutable_version();

        ::std::string *release_version();

        void set_allocated_version(::std::string *version);

        // string clientRandom = 2;
        void clear_clientrandom();

        static const int kClientRandomFieldNumber = 2;

        const ::std::string &clientrandom() const;

        void set_clientrandom(const ::std::string &value);

#if LANG_CXX11

        void set_clientrandom(::std::string &&value);

#endif

        void set_clientrandom(const char *value);

        void set_clientrandom(const char *value, size_t size);

        ::std::string *mutable_clientrandom();

        ::std::string *release_clientrandom();

        void set_allocated_clientrandom(::std::string *clientrandom);

        // string sessionId = 3;
        void clear_sessionid();

        static const int kSessionIdFieldNumber = 3;

        const ::std::string &sessionid() const;

        void set_sessionid(const ::std::string &value);

#if LANG_CXX11

        void set_sessionid(::std::string &&value);

#endif

        void set_sessionid(const char *value);

        void set_sessionid(const char *value, size_t size);

        ::std::string *mutable_sessionid();

        ::std::string *release_sessionid();

        void set_allocated_sessionid(::std::string *sessionid);

        // @@protoc_insertion_point(class_scope:proto.ClientHello)
    private:

        ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
        ::google::protobuf::internal::ArenaStringPtr version_;
        ::google::protobuf::internal::ArenaStringPtr clientrandom_;
        ::google::protobuf::internal::ArenaStringPtr sessionid_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        friend struct ::protobuf_proto_2fSecurity_2eproto::TableStruct;
    };
// -------------------------------------------------------------------

    class ServerHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ServerHello) */ {
    public:
        ServerHello();

        virtual ~ServerHello();

        ServerHello(const ServerHello &from);

        inline ServerHello &operator=(const ServerHello &from) {
            CopyFrom(from);
            return *this;
        }

#if LANG_CXX11

        ServerHello(ServerHello &&from) noexcept
                : ServerHello() {
            *this = ::std::move(from);
        }

        inline ServerHello &operator=(ServerHello &&from) noexcept {
            if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                if (this != &from) InternalSwap(&from);
            } else {
                CopyFrom(from);
            }
            return *this;
        }

#endif

        static const ::google::protobuf::Descriptor *descriptor();

        static const ServerHello &default_instance();

        static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
        static inline const ServerHello *internal_default_instance() {
            return reinterpret_cast<const ServerHello *>(
                    &_ServerHello_default_instance_);
        }

        static constexpr int kIndexInFileMessages =
                1;

        void Swap(ServerHello *other);

        friend void swap(ServerHello &a, ServerHello &b) {
            a.Swap(&b);
        }

        // implements Message ----------------------------------------------

        inline ServerHello *New() const final {
            return CreateMaybeMessage <ServerHello>(NULL);
        }

        ServerHello *New(::google::protobuf::Arena *arena) const final {
            return CreateMaybeMessage <ServerHello>(arena);
        }

        void CopyFrom(const ::google::protobuf::Message &from) final;

        void MergeFrom(const ::google::protobuf::Message &from) final;

        void CopyFrom(const ServerHello &from);

        void MergeFrom(const ServerHello &from);

        void Clear() final;

        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input) final;

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const final;

        ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
                bool deterministic, ::google::protobuf::uint8 *target) const final;

        int GetCachedSize() const final { return _cached_size_.Get(); }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const final;

        void InternalSwap(ServerHello *other);

    private:
        inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
            return NULL;
        }

        inline void *MaybeArenaPtr() const {
            return NULL;
        }

    public:

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // string version = 1;
        void clear_version();

        static const int kVersionFieldNumber = 1;

        const ::std::string &version() const;

        void set_version(const ::std::string &value);

#if LANG_CXX11

        void set_version(::std::string &&value);

#endif

        void set_version(const char *value);

        void set_version(const char *value, size_t size);

        ::std::string *mutable_version();

        ::std::string *release_version();

        void set_allocated_version(::std::string *version);

        // string serverRandom = 2;
        void clear_serverrandom();

        static const int kServerRandomFieldNumber = 2;

        const ::std::string &serverrandom() const;

        void set_serverrandom(const ::std::string &value);

#if LANG_CXX11

        void set_serverrandom(::std::string &&value);

#endif

        void set_serverrandom(const char *value);

        void set_serverrandom(const char *value, size_t size);

        ::std::string *mutable_serverrandom();

        ::std::string *release_serverrandom();

        void set_allocated_serverrandom(::std::string *serverrandom);

        // string sessionId = 3;
        void clear_sessionid();

        static const int kSessionIdFieldNumber = 3;

        const ::std::string &sessionid() const;

        void set_sessionid(const ::std::string &value);

#if LANG_CXX11

        void set_sessionid(::std::string &&value);

#endif

        void set_sessionid(const char *value);

        void set_sessionid(const char *value, size_t size);

        ::std::string *mutable_sessionid();

        ::std::string *release_sessionid();

        void set_allocated_sessionid(::std::string *sessionid);

        // bytes certificate = 4;
        void clear_certificate();

        static const int kCertificateFieldNumber = 4;

        const ::std::string &certificate() const;

        void set_certificate(const ::std::string &value);

#if LANG_CXX11

        void set_certificate(::std::string &&value);

#endif

        void set_certificate(const char *value);

        void set_certificate(const void *value, size_t size);

        ::std::string *mutable_certificate();

        ::std::string *release_certificate();

        void set_allocated_certificate(::std::string *certificate);

        // @@protoc_insertion_point(class_scope:proto.ServerHello)
    private:

        ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
        ::google::protobuf::internal::ArenaStringPtr version_;
        ::google::protobuf::internal::ArenaStringPtr serverrandom_;
        ::google::protobuf::internal::ArenaStringPtr sessionid_;
        ::google::protobuf::internal::ArenaStringPtr certificate_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        friend struct ::protobuf_proto_2fSecurity_2eproto::TableStruct;
    };
// -------------------------------------------------------------------

    class ClientSecurity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ClientSecurity) */ {
    public:
        ClientSecurity();

        virtual ~ClientSecurity();

        ClientSecurity(const ClientSecurity &from);

        inline ClientSecurity &operator=(const ClientSecurity &from) {
            CopyFrom(from);
            return *this;
        }

#if LANG_CXX11

        ClientSecurity(ClientSecurity &&from) noexcept
                : ClientSecurity() {
            *this = ::std::move(from);
        }

        inline ClientSecurity &operator=(ClientSecurity &&from) noexcept {
            if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                if (this != &from) InternalSwap(&from);
            } else {
                CopyFrom(from);
            }
            return *this;
        }

#endif

        static const ::google::protobuf::Descriptor *descriptor();

        static const ClientSecurity &default_instance();

        static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
        static inline const ClientSecurity *internal_default_instance() {
            return reinterpret_cast<const ClientSecurity *>(
                    &_ClientSecurity_default_instance_);
        }

        static constexpr int kIndexInFileMessages =
                2;

        void Swap(ClientSecurity *other);

        friend void swap(ClientSecurity &a, ClientSecurity &b) {
            a.Swap(&b);
        }

        // implements Message ----------------------------------------------

        inline ClientSecurity *New() const final {
            return CreateMaybeMessage <ClientSecurity>(NULL);
        }

        ClientSecurity *New(::google::protobuf::Arena *arena) const final {
            return CreateMaybeMessage <ClientSecurity>(arena);
        }

        void CopyFrom(const ::google::protobuf::Message &from) final;

        void MergeFrom(const ::google::protobuf::Message &from) final;

        void CopyFrom(const ClientSecurity &from);

        void MergeFrom(const ClientSecurity &from);

        void Clear() final;

        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input) final;

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const final;

        ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
                bool deterministic, ::google::protobuf::uint8 *target) const final;

        int GetCachedSize() const final { return _cached_size_.Get(); }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const final;

        void InternalSwap(ClientSecurity *other);

    private:
        inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
            return NULL;
        }

        inline void *MaybeArenaPtr() const {
            return NULL;
        }

    public:

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // bytes pre_master_secret = 1;
        void clear_pre_master_secret();

        static const int kPreMasterSecretFieldNumber = 1;

        const ::std::string &pre_master_secret() const;

        void set_pre_master_secret(const ::std::string &value);

#if LANG_CXX11

        void set_pre_master_secret(::std::string &&value);

#endif

        void set_pre_master_secret(const char *value);

        void set_pre_master_secret(const void *value, size_t size);

        ::std::string *mutable_pre_master_secret();

        ::std::string *release_pre_master_secret();

        void set_allocated_pre_master_secret(::std::string *pre_master_secret);

        // @@protoc_insertion_point(class_scope:proto.ClientSecurity)
    private:

        ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
        ::google::protobuf::internal::ArenaStringPtr pre_master_secret_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        friend struct ::protobuf_proto_2fSecurity_2eproto::TableStruct;
    };
// -------------------------------------------------------------------

    class ClientSecurityResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.ClientSecurityResponse) */ {
    public:
        ClientSecurityResponse();

        virtual ~ClientSecurityResponse();

        ClientSecurityResponse(const ClientSecurityResponse &from);

        inline ClientSecurityResponse &operator=(const ClientSecurityResponse &from) {
            CopyFrom(from);
            return *this;
        }

#if LANG_CXX11

        ClientSecurityResponse(ClientSecurityResponse &&from) noexcept
                : ClientSecurityResponse() {
            *this = ::std::move(from);
        }

        inline ClientSecurityResponse &operator=(ClientSecurityResponse &&from) noexcept {
            if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                if (this != &from) InternalSwap(&from);
            } else {
                CopyFrom(from);
            }
            return *this;
        }

#endif

        static const ::google::protobuf::Descriptor *descriptor();

        static const ClientSecurityResponse &default_instance();

        static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
        static inline const ClientSecurityResponse *internal_default_instance() {
            return reinterpret_cast<const ClientSecurityResponse *>(
                    &_ClientSecurityResponse_default_instance_);
        }

        static constexpr int kIndexInFileMessages =
                3;

        void Swap(ClientSecurityResponse *other);

        friend void swap(ClientSecurityResponse &a, ClientSecurityResponse &b) {
            a.Swap(&b);
        }

        // implements Message ----------------------------------------------

        inline ClientSecurityResponse *New() const final {
            return CreateMaybeMessage <ClientSecurityResponse>(NULL);
        }

        ClientSecurityResponse *New(::google::protobuf::Arena *arena) const final {
            return CreateMaybeMessage <ClientSecurityResponse>(arena);
        }

        void CopyFrom(const ::google::protobuf::Message &from) final;

        void MergeFrom(const ::google::protobuf::Message &from) final;

        void CopyFrom(const ClientSecurityResponse &from);

        void MergeFrom(const ClientSecurityResponse &from);

        void Clear() final;

        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input) final;

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const final;

        ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
                bool deterministic, ::google::protobuf::uint8 *target) const final;

        int GetCachedSize() const final { return _cached_size_.Get(); }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const final;

        void InternalSwap(ClientSecurityResponse *other);

    private:
        inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
            return NULL;
        }

        inline void *MaybeArenaPtr() const {
            return NULL;
        }

    public:

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // @@protoc_insertion_point(class_scope:proto.ClientSecurityResponse)
    private:

        ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        friend struct ::protobuf_proto_2fSecurity_2eproto::TableStruct;
    };
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientHello

// string version = 1;
    inline void ClientHello::clear_version() {
        version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ClientHello::version() const {
        // @@protoc_insertion_point(field_get:proto.ClientHello.version)
        return version_.GetNoArena();
    }

    inline void ClientHello::set_version(const ::std::string &value) {

        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ClientHello.version)
    }

#if LANG_CXX11

    inline void ClientHello::set_version(::std::string &&value) {

        version_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ClientHello.version)
    }

#endif

    inline void ClientHello::set_version(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ClientHello.version)
    }

    inline void ClientHello::set_version(const char *value, size_t size) {

        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                            ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ClientHello.version)
    }

    inline ::std::string *ClientHello::mutable_version() {

        // @@protoc_insertion_point(field_mutable:proto.ClientHello.version)
        return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ClientHello::release_version() {
        // @@protoc_insertion_point(field_release:proto.ClientHello.version)

        return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ClientHello::set_allocated_version(::std::string *version) {
        if (version != NULL) {

        } else {

        }
        version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
        // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.version)
    }

// string clientRandom = 2;
    inline void ClientHello::clear_clientrandom() {
        clientrandom_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ClientHello::clientrandom() const {
        // @@protoc_insertion_point(field_get:proto.ClientHello.clientRandom)
        return clientrandom_.GetNoArena();
    }

    inline void ClientHello::set_clientrandom(const ::std::string &value) {

        clientrandom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ClientHello.clientRandom)
    }

#if LANG_CXX11

    inline void ClientHello::set_clientrandom(::std::string &&value) {

        clientrandom_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ClientHello.clientRandom)
    }

#endif

    inline void ClientHello::set_clientrandom(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        clientrandom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ClientHello.clientRandom)
    }

    inline void ClientHello::set_clientrandom(const char *value, size_t size) {

        clientrandom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                                 ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ClientHello.clientRandom)
    }

    inline ::std::string *ClientHello::mutable_clientrandom() {

        // @@protoc_insertion_point(field_mutable:proto.ClientHello.clientRandom)
        return clientrandom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ClientHello::release_clientrandom() {
        // @@protoc_insertion_point(field_release:proto.ClientHello.clientRandom)

        return clientrandom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ClientHello::set_allocated_clientrandom(::std::string *clientrandom) {
        if (clientrandom != NULL) {

        } else {

        }
        clientrandom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientrandom);
        // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.clientRandom)
    }

// string sessionId = 3;
    inline void ClientHello::clear_sessionid() {
        sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ClientHello::sessionid() const {
        // @@protoc_insertion_point(field_get:proto.ClientHello.sessionId)
        return sessionid_.GetNoArena();
    }

    inline void ClientHello::set_sessionid(const ::std::string &value) {

        sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ClientHello.sessionId)
    }

#if LANG_CXX11

    inline void ClientHello::set_sessionid(::std::string &&value) {

        sessionid_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ClientHello.sessionId)
    }

#endif

    inline void ClientHello::set_sessionid(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ClientHello.sessionId)
    }

    inline void ClientHello::set_sessionid(const char *value, size_t size) {

        sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                              ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ClientHello.sessionId)
    }

    inline ::std::string *ClientHello::mutable_sessionid() {

        // @@protoc_insertion_point(field_mutable:proto.ClientHello.sessionId)
        return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ClientHello::release_sessionid() {
        // @@protoc_insertion_point(field_release:proto.ClientHello.sessionId)

        return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ClientHello::set_allocated_sessionid(::std::string *sessionid) {
        if (sessionid != NULL) {

        } else {

        }
        sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
        // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.sessionId)
    }

// -------------------------------------------------------------------

// ServerHello

// string version = 1;
    inline void ServerHello::clear_version() {
        version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ServerHello::version() const {
        // @@protoc_insertion_point(field_get:proto.ServerHello.version)
        return version_.GetNoArena();
    }

    inline void ServerHello::set_version(const ::std::string &value) {

        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ServerHello.version)
    }

#if LANG_CXX11

    inline void ServerHello::set_version(::std::string &&value) {

        version_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ServerHello.version)
    }

#endif

    inline void ServerHello::set_version(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ServerHello.version)
    }

    inline void ServerHello::set_version(const char *value, size_t size) {

        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                            ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ServerHello.version)
    }

    inline ::std::string *ServerHello::mutable_version() {

        // @@protoc_insertion_point(field_mutable:proto.ServerHello.version)
        return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ServerHello::release_version() {
        // @@protoc_insertion_point(field_release:proto.ServerHello.version)

        return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ServerHello::set_allocated_version(::std::string *version) {
        if (version != NULL) {

        } else {

        }
        version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
        // @@protoc_insertion_point(field_set_allocated:proto.ServerHello.version)
    }

// string serverRandom = 2;
    inline void ServerHello::clear_serverrandom() {
        serverrandom_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ServerHello::serverrandom() const {
        // @@protoc_insertion_point(field_get:proto.ServerHello.serverRandom)
        return serverrandom_.GetNoArena();
    }

    inline void ServerHello::set_serverrandom(const ::std::string &value) {

        serverrandom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ServerHello.serverRandom)
    }

#if LANG_CXX11

    inline void ServerHello::set_serverrandom(::std::string &&value) {

        serverrandom_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ServerHello.serverRandom)
    }

#endif

    inline void ServerHello::set_serverrandom(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        serverrandom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ServerHello.serverRandom)
    }

    inline void ServerHello::set_serverrandom(const char *value, size_t size) {

        serverrandom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                                 ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ServerHello.serverRandom)
    }

    inline ::std::string *ServerHello::mutable_serverrandom() {

        // @@protoc_insertion_point(field_mutable:proto.ServerHello.serverRandom)
        return serverrandom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ServerHello::release_serverrandom() {
        // @@protoc_insertion_point(field_release:proto.ServerHello.serverRandom)

        return serverrandom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ServerHello::set_allocated_serverrandom(::std::string *serverrandom) {
        if (serverrandom != NULL) {

        } else {

        }
        serverrandom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverrandom);
        // @@protoc_insertion_point(field_set_allocated:proto.ServerHello.serverRandom)
    }

// string sessionId = 3;
    inline void ServerHello::clear_sessionid() {
        sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ServerHello::sessionid() const {
        // @@protoc_insertion_point(field_get:proto.ServerHello.sessionId)
        return sessionid_.GetNoArena();
    }

    inline void ServerHello::set_sessionid(const ::std::string &value) {

        sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ServerHello.sessionId)
    }

#if LANG_CXX11

    inline void ServerHello::set_sessionid(::std::string &&value) {

        sessionid_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ServerHello.sessionId)
    }

#endif

    inline void ServerHello::set_sessionid(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ServerHello.sessionId)
    }

    inline void ServerHello::set_sessionid(const char *value, size_t size) {

        sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                              ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ServerHello.sessionId)
    }

    inline ::std::string *ServerHello::mutable_sessionid() {

        // @@protoc_insertion_point(field_mutable:proto.ServerHello.sessionId)
        return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ServerHello::release_sessionid() {
        // @@protoc_insertion_point(field_release:proto.ServerHello.sessionId)

        return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ServerHello::set_allocated_sessionid(::std::string *sessionid) {
        if (sessionid != NULL) {

        } else {

        }
        sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
        // @@protoc_insertion_point(field_set_allocated:proto.ServerHello.sessionId)
    }

// bytes certificate = 4;
    inline void ServerHello::clear_certificate() {
        certificate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ServerHello::certificate() const {
        // @@protoc_insertion_point(field_get:proto.ServerHello.certificate)
        return certificate_.GetNoArena();
    }

    inline void ServerHello::set_certificate(const ::std::string &value) {

        certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ServerHello.certificate)
    }

#if LANG_CXX11

    inline void ServerHello::set_certificate(::std::string &&value) {

        certificate_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ServerHello.certificate)
    }

#endif

    inline void ServerHello::set_certificate(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ServerHello.certificate)
    }

    inline void ServerHello::set_certificate(const void *value, size_t size) {

        certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                                ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ServerHello.certificate)
    }

    inline ::std::string *ServerHello::mutable_certificate() {

        // @@protoc_insertion_point(field_mutable:proto.ServerHello.certificate)
        return certificate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ServerHello::release_certificate() {
        // @@protoc_insertion_point(field_release:proto.ServerHello.certificate)

        return certificate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ServerHello::set_allocated_certificate(::std::string *certificate) {
        if (certificate != NULL) {

        } else {

        }
        certificate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), certificate);
        // @@protoc_insertion_point(field_set_allocated:proto.ServerHello.certificate)
    }

// -------------------------------------------------------------------

// ClientSecurity

// bytes pre_master_secret = 1;
    inline void ClientSecurity::clear_pre_master_secret() {
        pre_master_secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline const ::std::string &ClientSecurity::pre_master_secret() const {
        // @@protoc_insertion_point(field_get:proto.ClientSecurity.pre_master_secret)
        return pre_master_secret_.GetNoArena();
    }

    inline void ClientSecurity::set_pre_master_secret(const ::std::string &value) {

        pre_master_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:proto.ClientSecurity.pre_master_secret)
    }

#if LANG_CXX11

    inline void ClientSecurity::set_pre_master_secret(::std::string &&value) {

        pre_master_secret_.SetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
        // @@protoc_insertion_point(field_set_rvalue:proto.ClientSecurity.pre_master_secret)
    }

#endif

    inline void ClientSecurity::set_pre_master_secret(const char *value) {
                GOOGLE_DCHECK(value != NULL);

        pre_master_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:proto.ClientSecurity.pre_master_secret)
    }

    inline void ClientSecurity::set_pre_master_secret(const void *value, size_t size) {

        pre_master_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                                      ::std::string(reinterpret_cast<const char *>(value), size));
        // @@protoc_insertion_point(field_set_pointer:proto.ClientSecurity.pre_master_secret)
    }

    inline ::std::string *ClientSecurity::mutable_pre_master_secret() {

        // @@protoc_insertion_point(field_mutable:proto.ClientSecurity.pre_master_secret)
        return pre_master_secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string *ClientSecurity::release_pre_master_secret() {
        // @@protoc_insertion_point(field_release:proto.ClientSecurity.pre_master_secret)

        return pre_master_secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline void ClientSecurity::set_allocated_pre_master_secret(::std::string *pre_master_secret) {
        if (pre_master_secret != NULL) {

        } else {

        }
        pre_master_secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pre_master_secret);
        // @@protoc_insertion_point(field_set_allocated:proto.ClientSecurity.pre_master_secret)
    }

// -------------------------------------------------------------------

// ClientSecurityResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_proto_2fSecurity_2eproto
